<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>浏览器渲染原理 | 记录前端学习的简易博客</title>
    <meta name="generator" content="VuePress 1.9.9">
    <link rel="icon" href="/blog/fire.png">
    <meta name="description" content="HTML字符串 ---&gt; 解析HTML ---&gt; 样式计算 ---&gt; 布局 ---&gt; 分层 ---&gt; 绘制 ---&gt; 分块 ---&gt; 光栅化 ---&gt; 画 ---&gt; 像素信息
&gt;
&gt; 当浏览器的网络线程收到HTML文档后。会产生一个渲染任务，并将其传递给渲染主线程的消息队列。
&gt; 在事件循环机制的作用下，渲染主线程取出消息队列中的渲染任务，开启渲染流程。
&gt;
&gt; 整个渲染流程分为 ...">
    
    <link rel="preload" href="/blog/assets/css/0.styles.53c9dc91.css" as="style"><link rel="preload" href="/blog/assets/js/app.ef606c2b.js" as="script"><link rel="preload" href="/blog/assets/js/6.ef046bf0.js" as="script"><link rel="preload" href="/blog/assets/js/3.0deb6e1a.js" as="script"><link rel="preload" href="/blog/assets/js/18.fe228f50.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.5af07e9e.js"><link rel="prefetch" href="/blog/assets/js/11.9cc54484.js"><link rel="prefetch" href="/blog/assets/js/12.20ff25fe.js"><link rel="prefetch" href="/blog/assets/js/13.c940e617.js"><link rel="prefetch" href="/blog/assets/js/14.c8649e1c.js"><link rel="prefetch" href="/blog/assets/js/15.b085bdb9.js"><link rel="prefetch" href="/blog/assets/js/16.f2cfb457.js"><link rel="prefetch" href="/blog/assets/js/17.16272ad3.js"><link rel="prefetch" href="/blog/assets/js/19.0339c5f2.js"><link rel="prefetch" href="/blog/assets/js/4.e6797422.js"><link rel="prefetch" href="/blog/assets/js/5.4ce720b1.js"><link rel="prefetch" href="/blog/assets/js/7.a7f1498d.js"><link rel="prefetch" href="/blog/assets/js/8.b4d7524e.js"><link rel="prefetch" href="/blog/assets/js/9.402f2816.js"><link rel="prefetch" href="/blog/assets/js/vuejs-paginate.e46ccda7.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.53c9dc91.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div id="vuepress-theme-blog__global-layout"><section id="header-wrapper"><header id="header"><div class="header-wrapper"><div class="title"><a href="/blog/" class="nav-link home-link">记录前端学习的简易博客 </a></div> <div class="header-right-wrap"><ul class="nav"><li class="nav-item"><a href="/blog/" class="nav-link">文章</a></li><li class="nav-item"><a href="/blog/tag/" class="nav-link">标签</a></li></ul> <div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></div></header></section> <div id="mobile-header"><div class="mobile-header-bar"><div class="mobile-header-title"><a href="/blog/" class="nav-link mobile-home-link">记录前端学习的简易博客 </a> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg></div> <div class="mobile-menu-wrapper"><hr class="menu-divider"> <ul class="mobile-nav"><li class="mobile-nav-item"><a href="/blog/" class="nav-link">文章</a></li><li class="mobile-nav-item"><a href="/blog/tag/" class="nav-link">标签</a></li> <li class="mobile-nav-item"><!----></li></ul></div></div></div> <div class="content-wrapper"><div id="vuepress-theme-blog__post-layout"><article itemscope="itemscope" itemtype="https://schema.org/BlogPosting" class="vuepress-blog-theme-content"><header><h1 itemprop="name headline" class="post-title">
        浏览器渲染原理
      </h1> <div class="post-meta"><div itemprop="publisher author" itemtype="http://schema.org/Person" itemscope="itemscope" class="post-meta-author"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-navigation"><polygon points="3 11 22 2 13 21 11 13 3 11"></polygon></svg> <span itemprop="name">JiuHous</span> <span itemprop="address">   in Suzhou</span></div> <div class="post-meta-date"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-clock"><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg> <time pubdate itemprop="datePublished" datetime="2023-05-23T00:00:00.000Z">
      2023-05-23
    </time></div> <ul itemprop="keywords" class="post-meta-tags"><li class="post-tag" data-v-42ccfcd5><a href="/blog/tag/浏览器" data-v-42ccfcd5><span data-v-42ccfcd5>浏览器</span></a></li></ul></div></header> <div itemprop="articleBody" class="content__default"><h2 id="什么叫渲染-render"><a href="#什么叫渲染-render" class="header-anchor">#</a> 什么叫渲染-render</h2> <blockquote><p>HTML字符串 ---&gt; 解析HTML ---&gt; 样式计算 ---&gt; 布局 ---&gt; 分层 ---&gt; 绘制 ---&gt; 分块 ---&gt; 光栅化 ---&gt; 画 ---&gt; 像素信息</p> <p>当浏览器的网络线程收到HTML文档后。会产生一个渲染任务，并将其传递给渲染主线程的消息队列。
在事件循环机制的作用下，渲染主线程取出消息队列中的渲染任务，开启渲染流程。</p> <p>整个渲染流程分为多个阶段，分别是:HTML解析、样式计算、布局、分层、绘制、分块、光栅化、画
每个阶段都有明确的输入输出，上一个阶段的输出会成为下一个阶段的输入。
这样，整个渲染流程就形成了一套组织严密的生产流水线。</p></blockquote> <h3 id="解析html"><a href="#解析html" class="header-anchor">#</a> 解析HTML</h3> <p>为了提高解析效率，浏览器会启动一个预解析的线程，率先下载HTML中的外部CSS文件和外部的JS文件。</p> <p>如果主线程解析到link位置，此时外部的CSS文件还没有下载解析好，主线程不会等待，继续解析后续的HTML。这是因为下载和解析CSS的工作是在预解析线程中进行的。这就是CSS 不会阻塞HTML解析的根本原因。</p> <p>如果主线程解析到script位置，会停止解析HTML，转而等待JS文件下载好，并将全局代码解析执行完成后，才能继续解析HTML。这是因为JS 代码的执行过程可能会修改当前的DOM 树，所以DOM树的生成必须暂停。这就是JS会阻塞HTML解析的根本原因。</p> <p>第一步完成后，会得到DOM树和CSSOM树，浏览器的默认样式、内部样式、外部样式、行内样式均会包含在CSSOM树中。</p> <h4 id="解析遇到css"><a href="#解析遇到css" class="header-anchor">#</a> 解析遇到CSS</h4> <p><img src="/blog/static/2023-5-23-002.png" alt="解析遇到css"></p> <h4 id="解析遇到js"><a href="#解析遇到js" class="header-anchor">#</a> 解析遇到JS</h4> <p>渲染主线程遇到JS时必须暂停一切行为，等待下载执行完后才能继续</p> <p>预解析线程可以分担一点下载JS的任务</p> <p><img src="/blog/static/2023-5-23-001.png" alt="解析遇到js"></p> <h3 id="样式计算"><a href="#样式计算" class="header-anchor">#</a> 样式计算</h3> <p>主线程会遍历得到的DOM树，依次为树中的每个节点计算出它最终的样式，称之为Computed Style。</p> <p>在这一过程中，很多预设值会变成绝对值，比如red会变成rgb(255,0,0)﹔相对单位会变成绝对单位，比如em会变成px。</p> <p>这一步完成后，会得到一棵带有样式的DOM树。</p> <p><img src="/blog/static/2023-5-23-003.png" alt="样式计算"></p> <h3 id="布局"><a href="#布局" class="header-anchor">#</a> 布局</h3> <p>布局阶段会依次遍历DOM树的每一个节点，计算每个节点的几何信息。例如节点的宽高、相对包含块的位置。</p> <p>大部分时候，DOM树和布局树井非——对应。</p> <p>比如display：none； 的节点没有几何信息，因此不会生成到布局树﹔又比如使用了伪元素选择器，虽然DOM树中不存在这些伪元素节点，但它们拥有几何信息，所以会生成到布局树中。还有匿名行盒、匿名块盒等等都会导致DoM树和布局树无法——对应。</p> <p><img src="/blog/static/2023-5-23-004.png" alt="布局"></p> <h3 id="分层"><a href="#分层" class="header-anchor">#</a> 分层</h3> <p>主线程会使用一套复杂的策略对整个布局树中进行分层。</p> <p>分层的好处在于，将来某一个层改变后，仅会对该层进行后续处理，从而提升效率。</p> <p>滚动条、堆叠上下文、transform、opacity 等样式都会或多或少的影响分层结果，也可以通过 will-change 届性更大程度的影响分层结果。</p> <p><img src="/blog/static/2023-5-23-005.png" alt="分层"></p> <h3 id="绘制"><a href="#绘制" class="header-anchor">#</a> 绘制</h3> <p>主线程会为每个层单独产生绘制指令集，用于描述这一层的内容该如何画出来</p> <p>完成绘制后，主线程将每个图层的绘制信息提交给合成线程，剩余工作将由合成线程完成</p> <p><img src="/blog/static/2023-5-23-006.png" alt="绘制"></p> <h3 id="分块"><a href="#分块" class="header-anchor">#</a> 分块</h3> <p>合成线程首先对每个图层进行分块，将其划分为更多的小区域</p> <p>它会从线程池中拿取多个线程来完成分块工作</p> <p><img src="/blog/static/2023-5-23-007.png" alt="分块"></p> <h3 id="光栅化"><a href="#光栅化" class="header-anchor">#</a> 光栅化</h3> <p>合成线程会将块信息交给GPU进程，以极高的速度完成光栅化</p> <p>GPU进程会开启多个线程来完成光栅化，并且优先处理靠近视口区域的块</p> <p>光栅化的结果，就是一块一块的位图</p> <p><img src="/blog/static/2023-5-23-008.png" alt="光栅化"></p> <h3 id="画"><a href="#画" class="header-anchor">#</a> 画</h3> <p>合成线程拿到每个层、每个块的位图后，生成一个个「指引（quad）」信息。</p> <p>指引会标识出每个位图应该画到屏幕的哪个位置，以及会考虑到旋转、缩放等变形。</p> <p>变形发生在合成线程，与渲染主线程无关，这就是<code>transform</code>效率高的本质原因。</p> <p>合成线程会把 quad 提交给 GPU 进程，由 GPU 进程产生系统调用，提交给 GPU 硬件，完成最终的屏幕成像。</p> <p><img src="/blog/static/2023-5-23-009.png" alt="画"></p> <h2 id="什么是reflow"><a href="#什么是reflow" class="header-anchor">#</a> 什么是reflow？</h2> <p>reflow 的本质就是重新计算 layout 树。</p> <p>当进行了会影响布局树的操作后，需要重新计算布局树，会引发 layout。</p> <p>为了避免连续的多次操作导致布局树反复计算，浏览器会合并这些操作，当 JS 代码全部完成后再进行统一计算。所以，改动属性造成的 reflow 是异步完成的。</p> <p>也同样因为如此，当 JS 获取布局属性时，就可能造成无法获取到最新的布局信息。</p> <p>浏览器在反复权衡下，最终决定获取属性立即 reflow。</p> <h2 id="什么是repaint"><a href="#什么是repaint" class="header-anchor">#</a> 什么是repaint？</h2> <p>repaint 的本质就是重新根据分层信息计算了绘制指令。</p> <p>当改动了可见样式后，就需要重新计算，会引发 repaint。</p> <p>由于元素的布局信息也属于可见样式，所以 reflow 一定会引起 repaint。</p> <h2 id="为什么transform的效率高"><a href="#为什么transform的效率高" class="header-anchor">#</a> 为什么transform的效率高</h2> <p>因为 transform 既不会影响布局也不会影响绘制指令，它影响的只是渲染流程的最后一个「draw」阶段</p> <p>由于 draw 阶段在合成线程中，所以 transform 的变化几乎不会影响渲染主线程。</p> <p>反之，渲染主线程无论如何忙碌，也不会影响 transform 的变化。</p></div> <footer><!----> <hr> <!----></footer></article> <div class="sticker vuepress-toc"><div class="vuepress-toc-item vuepress-toc-h2 active"><a href="#什么叫渲染-render" title="什么叫渲染-render">什么叫渲染-render</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#解析html" title="解析HTML">解析HTML</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#样式计算" title="样式计算">样式计算</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#布局" title="布局">布局</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#分层" title="分层">分层</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#绘制" title="绘制">绘制</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#分块" title="分块">分块</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#光栅化" title="光栅化">光栅化</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#画" title="画">画</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#什么是reflow" title="什么是reflow？">什么是reflow？</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#什么是repaint" title="什么是repaint？">什么是repaint？</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#为什么transform的效率高" title="为什么transform的效率高">为什么transform的效率高</a></div></div></div></div> <footer class="footer" data-v-3d9deeb8><div class="footer-left-wrap" data-v-3d9deeb8><ul class="contact" data-v-3d9deeb8><li class="contact-item" data-v-3d9deeb8><a href="https://github.com/guo-429010" target="_blank" rel="noopener noreferrer" class="nav-link external" data-v-3d9deeb8><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github" data-v-3d9deeb8><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22" data-v-3d9deeb8></path></svg>
          
        </a></li></ul></div> <div class="footer-right-wrap" data-v-3d9deeb8><ul class="copyright" data-v-3d9deeb8><li class="copyright-item" data-v-3d9deeb8><a href="http://admin.guo123.top" target="_blank" rel="noopener noreferrer" class="nav-link external" data-v-3d9deeb8>个人网站后台</a></li><li class="copyright-item" data-v-3d9deeb8>guo123.top | © 2023-present Vue.js</li></ul></div></footer></div><div class="global-ui"></div></div>
    <script src="/blog/assets/js/app.ef606c2b.js" defer></script><script src="/blog/assets/js/6.ef046bf0.js" defer></script><script src="/blog/assets/js/3.0deb6e1a.js" defer></script><script src="/blog/assets/js/18.fe228f50.js" defer></script>
  </body>
</html>
